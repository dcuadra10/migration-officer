{"file_contents":{"bot.js":{"content":"const { Client, GatewayIntentBits } = require('discord.js');\nconst express = require('express');\nrequire('dotenv').config();\n\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent\n  ]\n});\n\n// Comando bÃ¡sico de migraciÃ³n\nclient.on('messageCreate', async (message) => {\n  if (message.content.startsWith('!migrar')) {\n    // SimulaciÃ³n de migraciÃ³n\n    const args = message.content.split(' ');\n    const jugador = args[1] || 'Desconocido';\n    const reino = args[2] || '???';\n\n    message.channel.send(`ğŸ›« MigraciÃ³n registrada: ${jugador} se va al reino ${reino}`);\n  }\n});\n\n// Servidor Express para mantener Replit activo\nconst app = express();\napp.get('/', (req, res) => {\n  res.send('Bot de migraciÃ³n activo ğŸš€');\n});\napp.listen(3000, () => {\n  console.log('Servidor web activo en puerto 3000');\n});\n\n// Login del bot\nclient.login(process.env.TOKEN);\n","size_bytes":952},"config.js":{"content":"const path = require('path');\n\nconst config = {\n    DISCORD_TOKEN: process.env.DISCORD_TOKEN || 'your_bot_token_here',\n    CLIENT_ID: process.env.CLIENT_ID || 'your_client_id_here',\n    PORT: process.env.PORT || 3000,\n    MAX_FILE_SIZE: 8 * 1024 * 1024, // 8MB max file size\n    ALLOWED_FILE_TYPES: ['image/jpeg', 'image/jpg', 'image/png', 'image/gif', 'image/webp'],\n    UPLOAD_DIR: path.join(__dirname, 'uploads')\n};\n\nmodule.exports = config;\n\n","size_bytes":446},"index.js":{"content":"require('dotenv').config();\nconst { Client, GatewayIntentBits, Partials, ChannelType } = require('discord.js');\nconst express = require('express');\nconst axios = require('axios');\n\nconst {\n  handleUserStep,\n  handleChannelDelete\n} = require('./stepsManager');\n\nconst {\n  notifyAdminsForApproval,\n  handleUserDM,\n  handleUserChannelCancel,\n  pendingRequests,\n  saveRequests\n} = require('./submitMigration');\n\nconst TOKEN = process.env.DISCORD_TOKEN;\nconst HEALTHCHECK_URL = process.env.HEALTHCHECK_URL;\n\nif (!TOKEN || !HEALTHCHECK_URL) {\n  console.error('âŒ Missing .env variables');\n  process.exit(1);\n}\n\n// ğŸŒ Express server for health monitoring\nconst app = express();\nlet lastPing = { method: null, timestamp: null };\n\napp.get('/health', (req, res) => {\n  lastPing = { method: 'GET', timestamp: new Date().toISOString() };\n  console.log(`[HEALTH] GET âœ…: ${lastPing.timestamp}`);\n  res.status(200).send('âœ… Healthcheck OK');\n});\n\napp.get('/status', (req, res) => {\n  if (!lastPing.timestamp) return res.status(200).send('â³ No ping received yet.');\n  res.status(200).json(lastPing);\n});\n\napp.listen(3000, () => {\n  console.log('ğŸŒ Express server running on port 3000');\n});\n\n// ğŸ¤– Discord bot setup\nconst client = new Client({\n  intents: [\n    GatewayIntentBits.Guilds,\n    GatewayIntentBits.GuildMessages,\n    GatewayIntentBits.MessageContent,\n    GatewayIntentBits.GuildMembers,\n    GatewayIntentBits.GuildMessageReactions,\n    GatewayIntentBits.DirectMessages\n  ],\n  partials: [\n    Partials.Channel,\n    Partials.User,\n    Partials.Message,\n    Partials.Reaction\n  ]\n});\n\nclient.once('ready', () => {\n  console.log(`ğŸ¤– Bot is online as ${client.user.tag}`);\n});\n\nclient.on('messageCreate', async (msg) => {\n  if (msg.author.bot) return;\n\n  const content = msg.content.trim();\n\n  if (msg.channel.type === ChannelType.DM) {\n    return handleUserDM(msg);\n  }\n\n  if (content.startsWith('!cancel')) {\n    return handleUserChannelCancel(msg);\n  }\n\n  return handleUserStep(msg);\n});\n\nclient.on('messageReactionAdd', async (reaction, user) => {\n  if (user.bot || !reaction.message) return;\n\n  const emoji = reaction.emoji.name;\n  const msg = reaction.message;\n\n  // âœ…âŒ Reacciones de admins\n  if (msg.embeds?.[0]?.title?.includes('solicitud de migraciÃ³n')) {\n    const match = msg.embeds[0].description?.match(/<@(\\d+)>/);\n    if (!match) return;\n\n    const userId = match[1];\n    const request = pendingRequests.get(userId);\n    if (!request) return;\n\n    const channel = await client.channels.fetch(request.channelId).catch(() => null);\n    const guild = channel?.guild;\n    const member = guild?.members.cache.get(userId);\n    const lang = request.language || 'en';\n\n    const messages = {\n      approve: {\n        es: 'âœ… Tu migraciÃ³n ha sido aprobada. Â¿ConfirmÃ¡s que vas a migrar?',\n        en: 'âœ… Your migration has been approved. Can you confirm that you will proceed with the migration?'\n      },\n      deny: {\n        es: 'âŒ Tu migraciÃ³n fue rechazada. Contacta a soporte si tienes dudas.',\n        en: 'âŒ Your migration was denied. Contact support if you have questions.'\n      }\n    };\n\n    const text = emoji === 'âœ…' ? messages.approve[lang] : messages.deny[lang];\n\n    let dmSent = false;\n    try {\n      if (!member) throw new Error('Miembro no encontrado en cache');\n      await member.send(text);\n      dmSent = true;\n      console.log(`ğŸ“¬ DM enviado a ${member.user.tag}: ${text}`);\n    } catch (err) {\n      console.error(`âŒ FallÃ³ el DM a <@${userId}>: ${err.message}`);\n    }\n\n    await channel?.send(`${emoji} <@${userId}> ha sido ${emoji === 'âœ…' ? 'aprobado' : 'rechazado'}. Idioma: ${lang}`);\n    if (!dmSent) {\n      await channel?.send(`âš ï¸ No se pudo enviar DM a <@${userId}>. Enviando mensaje aquÃ­:\\n${text}`);\n    }\n\n    pendingRequests.delete(userId);\n    saveRequests();\n\n    if (channel?.name?.startsWith('ticket-')) {\n      try {\n        await channel.send('ğŸ“Œ Este canal se cerrarÃ¡ en breve...');\n        setTimeout(() => channel.delete().catch(() => {}), 5000);\n      } catch (err) {\n        console.error(`âŒ No se pudo eliminar el canal ${channel.name}: ${err.message}`);\n      }\n    }\n  }\n\n  // ğŸš« ReacciÃ³n de cancelaciÃ³n del usuario\n  for (const [userId, request] of pendingRequests.entries()) {\n    if (user.id !== userId) continue;\n    if (reaction.message.id !== request.lastMessageId) continue;\n    if (emoji !== 'ğŸš«') continue;\n\n    const channel = await client.channels.fetch(request.channelId).catch(() => null);\n    await channel?.send(`ğŸš« <@${userId}> cancelÃ³ su solicitud desde la reacciÃ³n.`);\n    pendingRequests.delete(userId);\n    saveRequests();\n\n    if (channel?.name?.startsWith('ticket-')) {\n      try {\n        await channel.delete();\n      } catch (err) {\n        console.error(`âŒ No se pudo eliminar el canal ${channel.name}: ${err.message}`);\n      }\n    }\n  }\n});\n\nclient.on('channelDelete', handleChannelDelete);\nclient.login(TOKEN);\n","size_bytes":4949},"parseUtils.js":{"content":"function parseValue(input) {\n  if (!input) return 0;\n  const str = input.toLowerCase().replace(/,/g, '').trim();\n  const match = str.match(/^([\\d.]+)([kmb])?$/);\n  if (!match) return parseInt(str, 10);\n  const num = parseFloat(match[1]);\n  const suffix = match[2];\n  switch (suffix) {\n    case 'k': return Math.round(num * 1_000);\n    case 'm': return Math.round(num * 1_000_000);\n    case 'b': return Math.round(num * 1_000_000_000);\n    default: return Math.round(num);\n  }\n}\n\nfunction calculatePoints({ power, kp, deaths }) {\n  return Math.floor((power / 10000) + (kp / 100000) + (deaths / 1000));\n}\n\nmodule.exports = { parseValue, calculatePoints };\n","size_bytes":654},"replit.md":{"content":"# Discord Bot Player Stats System\n\n## Overview\n\nThis is a Discord bot application that manages player statistics and screenshot uploads for what appears to be a gaming community. The system combines a Discord bot with a web server to handle player data management and file uploads.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Backend Architecture\n- **Node.js** application with two main components:\n  - Discord bot client using discord.js v14\n  - Express web server for file uploads and API endpoints\n- **File-based database** using JSON storage with in-memory Map for performance\n- **Modular command system** with separate command handlers\n\n### Storage Solution\n- **Local JSON file storage** (`players.json`) for player data persistence\n- **File system storage** for uploaded screenshots in `./uploads` directory\n- **In-memory Map** for fast data access during runtime\n\n### Bot Architecture\n- **Slash commands** for Discord interactions\n- **Intent-based permissions** for guild messages and direct messages\n- **Embed-based responses** for rich Discord messages\n\n## Key Components\n\n### 1. Discord Bot Client (`index.js`)\n- Initializes Discord client with necessary intents\n- Registers slash commands for player management\n- Handles bot authentication and connection\n\n### 2. Web Server (`server.js`)\n- Express server running on configurable port (default 8000)\n- Multer middleware for file upload handling\n- CORS enabled for cross-origin requests\n- Static file serving for uploaded screenshots\n\n### 3. Database Layer (`storage/database.js`)\n- Simple file-based storage system\n- Maps player IDs to player objects\n- Automatic file persistence on data changes\n- In-memory caching for performance\n\n### 4. Command System\n- **Stats Command** (`commands/stats.js`): Handles player addition and statistics management\n- **Upload Command** (`commands/upload.js`): Manages screenshot uploads and associations\n\n### 5. Utilities\n- **File Handler** (`utils/fileHandler.js`): Validates and processes file uploads\n- **Config** (`config.js`): Centralized configuration management\n\n## Data Flow\n\n### Player Management Flow\n1. Discord user issues `/addplayer` command\n2. Bot validates player ID uniqueness\n3. Player data stored in memory Map and persisted to JSON file\n4. Confirmation sent via Discord embed\n\n### Screenshot Upload Flow\n1. User uploads screenshot via Discord command\n2. File validated for type and size limits\n3. File downloaded from Discord CDN to local storage\n4. File association stored in player's record\n5. Confirmation sent with file details\n\n### Data Persistence Flow\n1. All player data changes trigger automatic file save\n2. On startup, JSON file loaded into memory Map\n3. File system used for screenshot storage with UUID naming\n\n## External Dependencies\n\n### Discord Integration\n- **discord.js v14**: Primary bot framework\n- **Discord API**: Slash commands and message handling\n- **Discord CDN**: Source for uploaded file downloads\n\n### File Processing\n- **Multer**: File upload middleware\n- **UUID**: Unique file naming\n- **Built-in Node.js modules**: fs, path, https, http for file operations\n\n### Web Framework\n- **Express v5**: Web server framework\n- **Built-in middleware**: JSON parsing, URL encoding, CORS\n\n## Deployment Strategy\n\n### Configuration\n- Environment variables for sensitive data (Discord tokens)\n- Configurable ports and file size limits\n- Centralized config management\n\n### File Storage\n- Local file system storage for uploads\n- Automatic directory creation for upload folder\n- Static file serving for web access to uploads\n\n### Process Management\n- Single Node.js process handling both bot and web server\n- File-based persistence eliminates database server dependency\n- Startup script configured in package.json\n\n### Security Considerations\n- File type validation for uploads\n- File size limits (8MB default)\n- CORS configuration for web requests\n- Environment variable protection for tokens\n\nThe system is designed for simplicity and ease of deployment, using file-based storage instead of a traditional database server. This makes it suitable for small to medium-sized Discord communities without requiring complex database setup.","size_bytes":4225},"server.js":{"content":"const express = require('express');\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs');\nconst config = require('./config');\nconst database = require('./storage/database');\n\nconst app = express();\n\n// Configure multer for file uploads\nconst storage = multer.diskStorage({\n    destination: (req, file, cb) => {\n        cb(null, config.UPLOAD_DIR);\n    },\n    filename: (req, file, cb) => {\n        const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n        cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));\n    }\n});\n\nconst upload = multer({\n    storage: storage,\n    limits: {\n        fileSize: config.MAX_FILE_SIZE\n    },\n    fileFilter: (req, file, cb) => {\n        if (config.ALLOWED_FILE_TYPES.includes(file.mimetype)) {\n            cb(null, true);\n        } else {\n            cb(new Error('Invalid file type'), false);\n        }\n    }\n});\n\n// Middleware\napp.use(express.json());\napp.use(express.urlencoded({ extended: true }));\n\n// Serve static files from uploads directory\napp.use('/uploads', express.static(config.UPLOAD_DIR));\n\n// CORS middleware for web requests\napp.use((req, res, next) => {\n    res.header('Access-Control-Allow-Origin', '*');\n    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');\n    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');\n    \n    if (req.method === 'OPTIONS') {\n        res.sendStatus(200);\n    } else {\n        next();\n    }\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n    res.json({ \n        status: 'healthy', \n        timestamp: new Date().toISOString(),\n        uptime: process.uptime()\n    });\n});\n\n// Get all players\napp.get('/api/players', (req, res) => {\n    try {\n        const players = database.getAllPlayers();\n        res.json(players);\n    } catch (error) {\n        console.error('Error getting players:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Get specific player\napp.get('/api/players/:id', (req, res) => {\n    try {\n        const player = database.getPlayer(req.params.id);\n        if (!player) {\n            return res.status(404).json({ error: 'Player not found' });\n        }\n        res.json(player);\n    } catch (error) {\n        console.error('Error getting player:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// File upload endpoint\napp.post('/api/upload/:playerId', upload.single('screenshot'), (req, res) => {\n    try {\n        const playerId = req.params.playerId;\n        const description = req.body.description || 'No description provided';\n\n        // Check if player exists\n        const player = database.getPlayer(playerId);\n        if (!player) {\n            return res.status(404).json({ error: 'Player not found' });\n        }\n\n        if (!req.file) {\n            return res.status(400).json({ error: 'No file uploaded' });\n        }\n\n        // Create screenshot record\n        const screenshot = {\n            id: req.file.filename,\n            filename: req.file.filename,\n            originalName: req.file.originalname,\n            url: `/uploads/${req.file.filename}`,\n            description: description,\n            uploadedAt: new Date().toISOString(),\n            size: req.file.size,\n            contentType: req.file.mimetype\n        };\n\n        // Add screenshot to player\n        database.addScreenshotToPlayer(playerId, screenshot);\n\n        res.json({\n            success: true,\n            message: 'Screenshot uploaded successfully',\n            screenshot: screenshot\n        });\n\n    } catch (error) {\n        console.error('Error uploading file:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Get player screenshots\napp.get('/api/players/:id/screenshots', (req, res) => {\n    try {\n        const screenshots = database.getPlayerScreenshots(req.params.id);\n        res.json(screenshots);\n    } catch (error) {\n        console.error('Error getting screenshots:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Database statistics endpoint\napp.get('/api/stats', (req, res) => {\n    try {\n        const stats = database.getStats();\n        res.json(stats);\n    } catch (error) {\n        console.error('Error getting stats:', error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Simple web interface\napp.get('/', (req, res) => {\n    res.send(`\n        <!DOCTYPE html>\n        <html>\n        <head>\n            <title>Discord Bot Dashboard</title>\n            <style>\n                body { font-family: Arial, sans-serif; margin: 40px; }\n                .container { max-width: 800px; margin: 0 auto; }\n                .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin: 20px 0; }\n                .stat-card { background: #f5f5f5; padding: 20px; border-radius: 8px; text-align: center; }\n                .stat-value { font-size: 2em; font-weight: bold; color: #333; }\n                .stat-label { font-size: 0.9em; color: #666; }\n                .endpoint { background: #e8f4f8; padding: 15px; margin: 10px 0; border-radius: 5px; }\n                .method { font-weight: bold; color: #0066cc; }\n            </style>\n        </head>\n        <body>\n            <div class=\"container\">\n                <h1>Discord Bot Dashboard</h1>\n                <p>Bot is running and connected to Discord!</p>\n                \n                <div id=\"stats\" class=\"stats\">\n                    <div class=\"stat-card\">\n                        <div class=\"stat-value\" id=\"playerCount\">Loading...</div>\n                        <div class=\"stat-label\">Players</div>\n                    </div>\n                    <div class=\"stat-card\">\n                        <div class=\"stat-value\" id=\"screenshotCount\">Loading...</div>\n                        <div class=\"stat-label\">Screenshots</div>\n                    </div>\n                    <div class=\"stat-card\">\n                        <div class=\"stat-value\" id=\"avgPower\">Loading...</div>\n                        <div class=\"stat-label\">Avg Power</div>\n                    </div>\n                    <div class=\"stat-card\">\n                        <div class=\"stat-value\" id=\"avgKp\">Loading...</div>\n                        <div class=\"stat-label\">Avg KP</div>\n                    </div>\n                </div>\n\n                <h2>Available API Endpoints</h2>\n                <div class=\"endpoint\">\n                    <span class=\"method\">GET</span> /api/players - Get all players\n                </div>\n                <div class=\"endpoint\">\n                    <span class=\"method\">GET</span> /api/players/:id - Get specific player\n                </div>\n                <div class=\"endpoint\">\n                    <span class=\"method\">POST</span> /api/upload/:playerId - Upload screenshot for player\n                </div>\n                <div class=\"endpoint\">\n                    <span class=\"method\">GET</span> /api/players/:id/screenshots - Get player screenshots\n                </div>\n                <div class=\"endpoint\">\n                    <span class=\"method\">GET</span> /api/stats - Get database statistics\n                </div>\n            </div>\n\n            <script>\n                // Load stats\n                fetch('/api/stats')\n                    .then(response => response.json())\n                    .then(data => {\n                        document.getElementById('playerCount').textContent = data.totalPlayers;\n                        document.getElementById('screenshotCount').textContent = data.totalScreenshots;\n                        document.getElementById('avgPower').textContent = Math.round(data.averagePower);\n                        document.getElementById('avgKp').textContent = Math.round(data.averageKp);\n                    })\n                    .catch(error => {\n                        console.error('Error loading stats:', error);\n                    });\n            </script>\n        </body>\n        </html>\n    `);\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n    if (error instanceof multer.MulterError) {\n        if (error.code === 'LIMIT_FILE_SIZE') {\n            return res.status(400).json({ error: 'File too large' });\n        }\n    }\n    \n    console.error('Server error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n});\n\n// Don't start server here - it's started in index.js\nmodule.exports = app;\n","size_bytes":8599},"stepsManager.js":{"content":"const { notifyAdminsForApproval, pendingRequests, saveRequests } = require('./submitMigration');\n\nconst pendingUserSteps = new Map();\n\nconst translations = {\n  es: {\n    ask_nickname: 'ğŸ§‘ Â¿CuÃ¡l es tu nickname?',\n    ask_id: 'ğŸ†” Â¿CuÃ¡l es tu ID de juego?',\n    ask_kingdom: 'ğŸ° Â¿En quÃ© reino estÃ¡s?',\n    ask_power: 'âš¡ Â¿CuÃ¡l es tu poder?',\n    ask_kp: 'ğŸ¯ Â¿CuÃ¡ntos kill points tenÃ©s?',\n    ask_deaths: 'ğŸ’€ Â¿CuÃ¡ntas muertes tenÃ©s?',\n    ask_screenshot: 'ğŸ“¸ SubÃ­ una captura de tu perfil.',\n    missing_image: 'âš ï¸ Necesito una imagen para continuar.',\n    confirm: 'âœ… Gracias. Tu solicitud serÃ¡ enviada a los administradores.'\n  },\n  en: {\n    ask_nickname: 'ğŸ§‘ What is your nickname?',\n    ask_id: 'ğŸ†” What is your in-game ID?',\n    ask_kingdom: 'ğŸ° What kingdom are you in?',\n    ask_power: 'âš¡ What is your power?',\n    ask_kp: 'ğŸ¯ How many kill points do you have?',\n    ask_deaths: 'ğŸ’€ How many deaths?',\n    ask_screenshot: 'ğŸ“¸ Please upload a screenshot of your profile.',\n    missing_image: 'âš ï¸ I need an image to continue.',\n    confirm: 'âœ… Thank you. Your request will be sent to the admins.'\n  }\n};\n\nasync function handleUserStep(msg) {\n  const userId = msg.author.id;\n  const content = msg.content?.trim();\n  const userState = pendingUserSteps.get(userId) || {\n    step: 'ask_nickname',\n    language: msg.locale?.startsWith('es') ? 'es' : 'en',\n    channelId: msg.channel.id\n  };\n\n  const t = translations[userState.language];\n\n  switch (userState.step) {\n    case 'ask_nickname':\n      userState.nickname = content;\n      userState.step = 'ask_id';\n      pendingUserSteps.set(userId, userState);\n      return msg.reply(t.ask_id);\n\n    case 'ask_id':\n      userState.ingame_id = content;\n      userState.step = 'ask_kingdom';\n      return msg.reply(t.ask_kingdom);\n\n    case 'ask_kingdom':\n      userState.kingdom = content;\n      userState.step = 'ask_power';\n      return msg.reply(t.ask_power);\n\n    case 'ask_power':\n      userState.power = content;\n      userState.step = 'ask_kp';\n      return msg.reply(t.ask_kp);\n\n    case 'ask_kp':\n      userState.kp = content;\n      userState.step = 'ask_deaths';\n      return msg.reply(t.ask_deaths);\n\n    case 'ask_deaths':\n      userState.deaths = content;\n      userState.step = 'ask_screenshot';\n      return msg.reply(t.ask_screenshot);\n\n    case 'ask_screenshot':\n      if (!msg.attachments.size) {\n        return msg.reply(t.missing_image);\n      }\n\n      userState.profile_image = msg.attachments.first().url;\n      userState.step = 'done';\n      pendingUserSteps.delete(userId);\n      msg.reply(t.confirm);\n\n      const summary = `\nğŸ§‘ Nickname: ${userState.nickname}\nğŸ†” ID: ${userState.ingame_id}\nğŸ° Kingdom: ${userState.kingdom}\nâš¡ Power: ${userState.power}\nğŸ¯ Kill Points: ${userState.kp}\nğŸ’€ Deaths: ${userState.deaths}\nğŸ“¸ Screenshot: ${userState.profile_image}\n`.trim();\n\n      try {\n        const approvalMessageId = await notifyAdminsForApproval(msg.client, userId, userState.language, summary);\n        pendingRequests.set(userId, {\n          channelId: msg.channel.id,\n          language: userState.language,\n          lastMessageId: msg.id,\n          approvalMessageId\n        });\n        saveRequests();\n      } catch (err) {\n        console.error(`âŒ Error al enviar solicitud: ${err.message}`);\n        msg.channel.send('âš ï¸ No se pudo enviar la solicitud a los administradores.');\n      }\n\n      return;\n  }\n\n  pendingUserSteps.set(userId, userState);\n}\n\nfunction handleChannelDelete(channel) {\n  for (const [userId, state] of pendingUserSteps.entries()) {\n    if (state.channelId === channel.id) {\n      pendingUserSteps.delete(userId);\n      console.log(`ğŸ§¹ Flujo cancelado para ${userId} por eliminaciÃ³n del canal`);\n    }\n  }\n}\n\nmodule.exports = {\n  handleUserStep,\n  pendingUserSteps,\n  handleChannelDelete\n};\n","size_bytes":3865},"submitMigration.js":{"content":"const { EmbedBuilder, PermissionsBitField } = require('discord.js');\nconst fs = require('fs');\nconst path = require('path');\n\nconst REQUESTS_FILE = path.join(__dirname, 'requests.json');\nconst pendingRequests = new Map();\n\n// ğŸ§  Cargar solicitudes previas\nif (fs.existsSync(REQUESTS_FILE)) {\n  try {\n    const raw = fs.readFileSync(REQUESTS_FILE);\n    const data = JSON.parse(raw);\n    for (const [userId, value] of Object.entries(data)) {\n      pendingRequests.set(userId, value);\n    }\n    console.log(`ğŸ“‚ Cargadas ${pendingRequests.size} solicitudes pendientes.`);\n  } catch (err) {\n    console.error('âŒ Error al cargar requests.json:', err.message);\n  }\n}\n\n// ğŸ’¾ Guardar solicitudes\nfunction saveRequests() {\n  const obj = Object.fromEntries(pendingRequests);\n  fs.writeFileSync(REQUESTS_FILE, JSON.stringify(obj, null, 2));\n}\n\n// ğŸ“¬ Enviar solicitud al canal de aprobaciones\nasync function notifyAdminsForApproval(client, userId, language, summary) {\n  const channelId = process.env.APPROVAL_CHANNEL_ID;\n  const channel = await client.channels.fetch(channelId).catch(() => null);\n  if (!channel) throw new Error('âŒ Canal de aprobaciÃ³n no encontrado');\n\n  const embed = new EmbedBuilder()\n    .setTitle('ğŸ“¥ Nueva solicitud de migraciÃ³n')\n    .setDescription(`Usuario: <@${userId}>\\nIdioma: ${language}\\n\\nResumen:\\n${summary || 'âš ï¸ No se proporcionÃ³ resumen.'}`)\n    .setColor(0x00bfff)\n    .setTimestamp();\n\n  const msg = await channel.send({ embeds: [embed] });\n  await msg.react('âœ…');\n  await msg.react('âŒ');\n\n  return msg.id;\n}\n\n// ğŸ“© Manejo de DM del usuario\nasync function handleUserDM(msg) {\n  const userId = msg.author.id;\n  const request = pendingRequests.get(userId);\n  if (!request) return;\n\n  await msg.reply(`ğŸ“¨ Tu solicitud estÃ¡ en revisiÃ³n. Idioma: ${request.language}`);\n}\n\n// ğŸš« CancelaciÃ³n desde canal\nasync function handleUserChannelCancel(msg) {\n  const userId = msg.author.id;\n  const request = pendingRequests.get(userId);\n  if (!request) return;\n  if (msg.channel.id !== request.channelId) return;\n\n  await msg.channel.send(`ğŸš« <@${userId}> cancelÃ³ su solicitud desde el canal.`);\n  pendingRequests.delete(userId);\n  saveRequests();\n\n  if (msg.channel.name.startsWith('ticket-')) {\n    try {\n      await msg.channel.delete();\n    } catch (err) {\n      console.error(`âŒ No se pudo eliminar el canal ${msg.channel.name}: ${err.message}`);\n    }\n  }\n}\n\n// ğŸ§© FunciÃ³n principal para crear ticket\nasync function submitMigration(interaction) {\n  const userId = interaction.user.id;\n  const guild = interaction.guild;\n  const client = interaction.client;\n  const lang = interaction.locale?.startsWith('es') ? 'es' : 'en';\n\n  const channelName = `ticket-${userId}`;\n  const existing = guild.channels.cache.find(c => c.name === channelName);\n  if (existing) {\n    return interaction.reply({ content: 'ğŸ“Œ Ya tienes un ticket abierto.', ephemeral: true });\n  }\n\n  const channel = await guild.channels.create({\n    name: channelName,\n    type: 0, // GUILD_TEXT\n    permissionOverwrites: [\n      {\n        id: guild.roles.everyone,\n        deny: [PermissionsBitField.Flags.ViewChannel]\n      },\n      {\n        id: userId,\n        allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages]\n      },\n      {\n        id: process.env.ADMIN_ROLE_ID,\n        allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.AddReactions]\n      },\n      {\n        id: client.user.id,\n        allow: [PermissionsBitField.Flags.ViewChannel, PermissionsBitField.Flags.SendMessages, PermissionsBitField.Flags.AddReactions]\n      }\n    ]\n  });\n\n  const summary = 'ğŸ“ El usuario ha solicitado migrar. Esperando aprobaciÃ³n.';\n  const approvalMessageId = await notifyAdminsForApproval(client, userId, lang, summary);\n\n  const ticketEmbed = new EmbedBuilder()\n    .setTitle(lang === 'es' ? 'Solicitud enviada' : 'Request Submitted')\n    .setDescription(lang === 'es'\n      ? 'Tu solicitud fue enviada a los administradores. Espera su aprobaciÃ³n.'\n      : 'Your request was sent to the admins. Please wait for approval.')\n    .setColor(0x00ff99)\n    .setTimestamp();\n\n  const ticketMsg = await channel.send({ embeds: [ticketEmbed] });\n  await ticketMsg.react('ğŸš«');\n\n  pendingRequests.set(userId, {\n    channelId: channel.id,\n    language: lang,\n    lastMessageId: ticketMsg.id,\n    approvalMessageId\n  });\n\n  saveRequests();\n\n  await interaction.reply({\n    content: lang === 'es'\n      ? 'âœ… Solicitud enviada. Revisa tu ticket.'\n      : 'âœ… Request submitted. Check your ticket.',\n    ephemeral: true\n  });\n}\n\n// âœ… Exportar funciones\nmodule.exports = {\n  submitMigration,\n  notifyAdminsForApproval,\n  handleUserDM,\n  handleUserChannelCancel,\n  pendingRequests,\n  saveRequests\n};\n","size_bytes":4770},"commands/stats.js":{"content":"const { EmbedBuilder } = require('discord.js');\nconst database = require('../storage/database');\n\nclass StatsCommand {\n    async addPlayer(interaction) {\n        const playerId = interaction.options.getString('id');\n        const power = interaction.options.getInteger('power') || 0;\n        const kp = interaction.options.getInteger('kp') || 0;\n\n        // Validate player ID\n        if (!playerId || playerId.trim().length === 0) {\n            await interaction.reply({ content: 'Player ID cannot be empty!', ephemeral: true });\n            return;\n        }\n\n        // Check if player already exists\n        const existingPlayer = database.getPlayer(playerId);\n        if (existingPlayer) {\n            await interaction.reply({ \n                content: `Player with ID \"${playerId}\" already exists! Use /updateplayer to modify their stats.`, \n                ephemeral: true \n            });\n            return;\n        }\n\n        // Add player to database\n        const player = {\n            id: playerId.trim(),\n            power: power,\n            kp: kp,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            screenshots: []\n        };\n\n        database.addPlayer(player);\n\n        const embed = new EmbedBuilder()\n            .setColor(0x00FF00)\n            .setTitle('Player Added Successfully')\n            .addFields(\n                { name: 'Player ID', value: player.id, inline: true },\n                { name: 'Power', value: player.power.toString(), inline: true },\n                { name: 'KP', value: player.kp.toString(), inline: true }\n            )\n            .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n    }\n\n    async updatePlayer(interaction) {\n        const playerId = interaction.options.getString('id');\n        const newPower = interaction.options.getInteger('power');\n        const newKp = interaction.options.getInteger('kp');\n\n        // Validate player ID\n        if (!playerId || playerId.trim().length === 0) {\n            await interaction.reply({ content: 'Player ID cannot be empty!', ephemeral: true });\n            return;\n        }\n\n        // Check if player exists\n        const player = database.getPlayer(playerId);\n        if (!player) {\n            await interaction.reply({ \n                content: `Player with ID \"${playerId}\" not found! Use /addplayer to add them first.`, \n                ephemeral: true \n            });\n            return;\n        }\n\n        // Update player stats\n        const updates = {};\n        if (newPower !== null) updates.power = newPower;\n        if (newKp !== null) updates.kp = newKp;\n\n        if (Object.keys(updates).length === 0) {\n            await interaction.reply({ \n                content: 'No updates provided! Please specify at least one stat to update.', \n                ephemeral: true \n            });\n            return;\n        }\n\n        const updatedPlayer = database.updatePlayer(playerId, updates);\n\n        const embed = new EmbedBuilder()\n            .setColor(0x0099FF)\n            .setTitle('Player Updated Successfully')\n            .addFields(\n                { name: 'Player ID', value: updatedPlayer.id, inline: true },\n                { name: 'Power', value: updatedPlayer.power.toString(), inline: true },\n                { name: 'KP', value: updatedPlayer.kp.toString(), inline: true }\n            )\n            .setFooter({ text: `Last updated: ${new Date(updatedPlayer.updatedAt).toLocaleString()}` })\n            .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n    }\n\n    async getPlayer(interaction) {\n        const playerId = interaction.options.getString('id');\n\n        // Validate player ID\n        if (!playerId || playerId.trim().length === 0) {\n            await interaction.reply({ content: 'Player ID cannot be empty!', ephemeral: true });\n            return;\n        }\n\n        // Get player from database\n        const player = database.getPlayer(playerId);\n        if (!player) {\n            await interaction.reply({ \n                content: `Player with ID \"${playerId}\" not found!`, \n                ephemeral: true \n            });\n            return;\n        }\n\n        const embed = new EmbedBuilder()\n            .setColor(0x0099FF)\n            .setTitle(`Player Stats: ${player.id}`)\n            .addFields(\n                { name: 'Power', value: player.power.toString(), inline: true },\n                { name: 'KP', value: player.kp.toString(), inline: true },\n                { name: 'Screenshots', value: player.screenshots.length.toString(), inline: true }\n            )\n            .setFooter({ text: `Created: ${new Date(player.createdAt).toLocaleString()}` })\n            .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n    }\n\n    async listPlayers(interaction) {\n        const players = database.getAllPlayers();\n\n        if (players.length === 0) {\n            await interaction.reply({ content: 'No players found in the database!', ephemeral: true });\n            return;\n        }\n\n        // Sort players by power (descending)\n        const sortedPlayers = players.sort((a, b) => b.power - a.power);\n\n        const embed = new EmbedBuilder()\n            .setColor(0x0099FF)\n            .setTitle(`Player Database (${players.length} players)`)\n            .setTimestamp();\n\n        // Add players to embed (limit to 25 fields due to Discord limits)\n        const displayPlayers = sortedPlayers.slice(0, 25);\n        \n        displayPlayers.forEach((player, index) => {\n            embed.addFields({\n                name: `${index + 1}. ${player.id}`,\n                value: `Power: ${player.power} | KP: ${player.kp}`,\n                inline: true\n            });\n        });\n\n        if (sortedPlayers.length > 25) {\n            embed.setFooter({ text: `Showing top 25 players out of ${players.length}` });\n        }\n\n        await interaction.reply({ embeds: [embed] });\n    }\n\n    async deletePlayer(interaction) {\n        const playerId = interaction.options.getString('id');\n\n        // Validate player ID\n        if (!playerId || playerId.trim().length === 0) {\n            await interaction.reply({ content: 'Player ID cannot be empty!', ephemeral: true });\n            return;\n        }\n\n        // Check if player exists\n        const player = database.getPlayer(playerId);\n        if (!player) {\n            await interaction.reply({ \n                content: `Player with ID \"${playerId}\" not found!`, \n                ephemeral: true \n            });\n            return;\n        }\n\n        // Delete player from database\n        database.deletePlayer(playerId);\n\n        const embed = new EmbedBuilder()\n            .setColor(0xFF0000)\n            .setTitle('Player Deleted Successfully')\n            .setDescription(`Player \"${playerId}\" has been removed from the database.`)\n            .setTimestamp();\n\n        await interaction.reply({ embeds: [embed] });\n    }\n}\n\nmodule.exports = StatsCommand;\n","size_bytes":7005},"commands/upload.js":{"content":"const { EmbedBuilder } = require('discord.js');\nconst database = require('../storage/database');\nconst fileHandler = require('../utils/fileHandler');\n\nclass UploadCommand {\n    async handleScreenshotUpload(interaction) {\n        const playerId = interaction.options.getString('player_id');\n        const description = interaction.options.getString('description') || 'No description provided';\n\n        // Validate player ID\n        if (!playerId || playerId.trim().length === 0) {\n            await interaction.reply({ content: 'Player ID cannot be empty!', ephemeral: true });\n            return;\n        }\n\n        // Check if player exists\n        const player = database.getPlayer(playerId);\n        if (!player) {\n            await interaction.reply({ \n                content: `Player with ID \"${playerId}\" not found! Use /addplayer to add them first.`, \n                ephemeral: true \n            });\n            return;\n        }\n\n        // Check for attachments\n        const attachment = interaction.options.getAttachment('screenshot');\n        if (!attachment) {\n            // Check if there are any attachments in the message\n            const messageAttachments = Array.from(interaction.message?.attachments?.values() || []);\n            if (messageAttachments.length === 0) {\n                await interaction.reply({ \n                    content: 'Please attach a screenshot file to upload!', \n                    ephemeral: true \n                });\n                return;\n            }\n        }\n\n        await interaction.deferReply();\n\n        try {\n            // Use the attachment from options or the first message attachment\n            const fileToUpload = attachment || Array.from(interaction.message.attachments.values())[0];\n            \n            // Validate file type and size\n            const validation = fileHandler.validateFile(fileToUpload);\n            if (!validation.valid) {\n                await interaction.editReply({ content: validation.error });\n                return;\n            }\n\n            // Download and save the file\n            const savedFile = await fileHandler.saveFile(fileToUpload, playerId);\n            \n            // Create screenshot record\n            const screenshot = {\n                id: savedFile.id,\n                filename: savedFile.filename,\n                originalName: fileToUpload.name,\n                url: fileToUpload.url,\n                description: description,\n                uploadedAt: new Date().toISOString(),\n                size: fileToUpload.size,\n                contentType: fileToUpload.contentType\n            };\n\n            // Add screenshot to player\n            database.addScreenshotToPlayer(playerId, screenshot);\n\n            const embed = new EmbedBuilder()\n                .setColor(0x00FF00)\n                .setTitle('Screenshot Uploaded Successfully')\n                .addFields(\n                    { name: 'Player ID', value: playerId, inline: true },\n                    { name: 'Description', value: description, inline: true },\n                    { name: 'File Size', value: `${(fileToUpload.size / 1024).toFixed(2)} KB`, inline: true }\n                )\n                .setImage(fileToUpload.url)\n                .setTimestamp();\n\n            await interaction.editReply({ embeds: [embed] });\n\n        } catch (error) {\n            console.error('Error uploading screenshot:', error);\n            await interaction.editReply({ \n                content: 'An error occurred while uploading the screenshot. Please try again.' \n            });\n        }\n    }\n}\n\nmodule.exports = UploadCommand;\n","size_bytes":3618},"storage/database.js":{"content":"const fs = require('fs');\nconst path = require('path');\n\nclass Database {\n    constructor() {\n        this.players = new Map();\n        this.dataFile = path.join(__dirname, 'players.json');\n    }\n\n    // Initialize database\n    init() {\n        this.loadFromFile();\n        console.log('Database initialized');\n    }\n\n    // Load data from file\n    loadFromFile() {\n        try {\n            if (fs.existsSync(this.dataFile)) {\n                const data = fs.readFileSync(this.dataFile, 'utf8');\n                const playersData = JSON.parse(data);\n                \n                // Convert array back to Map\n                this.players = new Map(playersData.map(player => [player.id, player]));\n                console.log(`Loaded ${this.players.size} players from file`);\n            }\n        } catch (error) {\n            console.error('Error loading database from file:', error);\n        }\n    }\n\n    // Save data to file\n    saveToFile() {\n        try {\n            // Convert Map to array for JSON serialization\n            const playersArray = Array.from(this.players.values());\n            fs.writeFileSync(this.dataFile, JSON.stringify(playersArray, null, 2));\n        } catch (error) {\n            console.error('Error saving database to file:', error);\n        }\n    }\n\n    // Add a new player\n    addPlayer(player) {\n        if (this.players.has(player.id)) {\n            throw new Error(`Player with ID ${player.id} already exists`);\n        }\n\n        this.players.set(player.id, player);\n        this.saveToFile();\n        return player;\n    }\n\n    // Get a player by ID\n    getPlayer(playerId) {\n        return this.players.get(playerId) || null;\n    }\n\n    // Update a player\n    updatePlayer(playerId, updates) {\n        const player = this.players.get(playerId);\n        if (!player) {\n            throw new Error(`Player with ID ${playerId} not found`);\n        }\n\n        // Update player properties\n        Object.assign(player, updates);\n        player.updatedAt = new Date().toISOString();\n\n        this.players.set(playerId, player);\n        this.saveToFile();\n        return player;\n    }\n\n    // Delete a player\n    deletePlayer(playerId) {\n        const deleted = this.players.delete(playerId);\n        if (deleted) {\n            this.saveToFile();\n        }\n        return deleted;\n    }\n\n    // Get all players\n    getAllPlayers() {\n        return Array.from(this.players.values());\n    }\n\n    // Add screenshot to player\n    addScreenshotToPlayer(playerId, screenshot) {\n        const player = this.players.get(playerId);\n        if (!player) {\n            throw new Error(`Player with ID ${playerId} not found`);\n        }\n\n        if (!player.screenshots) {\n            player.screenshots = [];\n        }\n\n        player.screenshots.push(screenshot);\n        player.updatedAt = new Date().toISOString();\n\n        this.players.set(playerId, player);\n        this.saveToFile();\n        return player;\n    }\n\n    // Get player screenshots\n    getPlayerScreenshots(playerId) {\n        const player = this.players.get(playerId);\n        return player ? player.screenshots || [] : [];\n    }\n\n    // Get database statistics\n    getStats() {\n        const players = Array.from(this.players.values());\n        const totalScreenshots = players.reduce((sum, player) => sum + (player.screenshots?.length || 0), 0);\n        \n        return {\n            totalPlayers: players.length,\n            totalScreenshots: totalScreenshots,\n            averagePower: players.length > 0 ? players.reduce((sum, p) => sum + p.power, 0) / players.length : 0,\n            averageKp: players.length > 0 ? players.reduce((sum, p) => sum + p.kp, 0) / players.length : 0\n        };\n    }\n}\n\nmodule.exports = new Database();\n","size_bytes":3732},"utils/fileHandler.js":{"content":"const fs = require('fs');\nconst path = require('path');\nconst https = require('https');\nconst http = require('http');\nconst { v4: uuidv4 } = require('uuid');\nconst config = require('../config');\n\nclass FileHandler {\n    constructor() {\n        this.ensureUploadDir();\n    }\n\n    // Ensure upload directory exists\n    ensureUploadDir() {\n        if (!fs.existsSync(config.UPLOAD_DIR)) {\n            fs.mkdirSync(config.UPLOAD_DIR, { recursive: true });\n        }\n    }\n\n    // Validate file type and size\n    validateFile(attachment) {\n        // Check file size\n        if (attachment.size > config.MAX_FILE_SIZE) {\n            return {\n                valid: false,\n                error: `File too large! Maximum size is ${config.MAX_FILE_SIZE / (1024 * 1024)}MB`\n            };\n        }\n\n        // Check file type\n        if (!config.ALLOWED_FILE_TYPES.includes(attachment.contentType)) {\n            return {\n                valid: false,\n                error: `Invalid file type! Allowed types: ${config.ALLOWED_FILE_TYPES.join(', ')}`\n            };\n        }\n\n        return { valid: true };\n    }\n\n    // Save file to local storage\n    async saveFile(attachment, playerId) {\n        return new Promise((resolve, reject) => {\n            const fileId = uuidv4();\n            const fileExtension = path.extname(attachment.name) || '.png';\n            const filename = `${playerId}_${fileId}${fileExtension}`;\n            const filepath = path.join(config.UPLOAD_DIR, filename);\n\n            // Choose http or https based on URL\n            const client = attachment.url.startsWith('https:') ? https : http;\n\n            const file = fs.createWriteStream(filepath);\n            \n            client.get(attachment.url, (response) => {\n                if (response.statusCode !== 200) {\n                    reject(new Error(`Failed to download file: ${response.statusCode}`));\n                    return;\n                }\n\n                response.pipe(file);\n\n                file.on('finish', () => {\n                    file.close();\n                    resolve({\n                        id: fileId,\n                        filename: filename,\n                        filepath: filepath,\n                        size: attachment.size\n                    });\n                });\n\n                file.on('error', (error) => {\n                    fs.unlink(filepath, () => {}); // Delete file on error\n                    reject(error);\n                });\n            }).on('error', (error) => {\n                reject(error);\n            });\n        });\n    }\n\n    // Delete file from storage\n    deleteFile(filename) {\n        const filepath = path.join(config.UPLOAD_DIR, filename);\n        \n        if (fs.existsSync(filepath)) {\n            fs.unlinkSync(filepath);\n            return true;\n        }\n        \n        return false;\n    }\n\n    // Get file info\n    getFileInfo(filename) {\n        const filepath = path.join(config.UPLOAD_DIR, filename);\n        \n        if (fs.existsSync(filepath)) {\n            const stats = fs.statSync(filepath);\n            return {\n                filename: filename,\n                size: stats.size,\n                created: stats.birthtime,\n                modified: stats.mtime\n            };\n        }\n        \n        return null;\n    }\n\n    // List all files in upload directory\n    listFiles() {\n        try {\n            const files = fs.readdirSync(config.UPLOAD_DIR);\n            return files.map(filename => this.getFileInfo(filename)).filter(Boolean);\n        } catch (error) {\n            console.error('Error listing files:', error);\n            return [];\n        }\n    }\n\n    // Clean up old files (optional utility)\n    cleanupOldFiles(daysOld = 30) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n\n        const files = this.listFiles();\n        let deletedCount = 0;\n\n        files.forEach(fileInfo => {\n            if (fileInfo.created < cutoffDate) {\n                if (this.deleteFile(fileInfo.filename)) {\n                    deletedCount++;\n                }\n            }\n        });\n\n        return deletedCount;\n    }\n}\n\nmodule.exports = new FileHandler();\n","size_bytes":4192}},"version":1}